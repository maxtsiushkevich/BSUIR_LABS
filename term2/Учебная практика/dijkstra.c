#include <limits.h>
include <stdio.h>
#include <stdbool.h>
// можете тут всяких приколов накидать, но алгоритм работает как надо
// описывется граф со стоимостями ребер. ребра могут существовать но стоить 0. алгоритм дейскстры реализован с восстановлением кратчайшего пути
int main()
{
    bool smezh[8][8] = {0, 1, 1, 0,0,0,0,0, //булева матрица смежности, если есть стоимость ребра 0
                        0,0,0,1,1,1,1,0,
                        0,0,0,1,1,1,1,0,
                        0,0,0,0,0,0,0,1,
                        0,0,0,0,0,0,0,1,
                        0,0,0,0,0,0,0,1,
                        0,0,0,0,0,0,0,1};

    int matr[8][8] = {0, 0, 0, 0, 0, 0, 0, 0,
                     0, 0,0, 4, 3, 5, 6, 0,
                     0,0,0,8,2,4,7, 0,
                     0,0,0,0,0,0,0,0,
                     0,0,0,0,0,0,0, 0,
                     0,0,0,0,0,0,0,0,
                     0,0,0,0,0,0,0, 0,
                     0,0,0,0,0,0,0,0}; // вершина 0-сток, вершина 7 - исток

    int flag[8]={0,0,0,0,0,0,0,0}; // посещенные вершины 0-не посещена, 1 посещена
    int dist[8]={INT_MAX, INT_MAX, INT_MAX, INT_MAX, INT_MAX, INT_MAX, INT_MAX, INT_MAX};
    dist[0] = 0;
    int tmp, point, i, temp;
    do
    {
       tmp=INT_MAX;
       point=INT_MAX;
       for (i=0; i<8; i++)
       {
           if ((dist[i] < tmp) && (flag[i] == 0)) // если расстояние меньше и веришна не посещена
           {
               tmp = dist[i];
               point = i;
           }
       }
       if(point!=INT_MAX)
       {
           for(i=0; i<8; i++)
           {
               if(matr[point][i] >= 0 && smezh[point][i] == true)
               {
                   temp=tmp+matr[point][i];
                   if (temp<dist[i])
                   {
                       dist[i]=temp;
                   }
               }
           }
           flag[point]=1;
       }
    } while (point<INT_MAX);
    printf("\nКратчайшие расстояния до вершин: \n");
    for (int i = 0; i<8; i++)
        printf("%5d ", dist[i]);
}